加密是通过在流模式下使用键控海绵结构来执行的，
显著的区别是，首先调用IsapRk来生成子键KE∗．IsapEnc得到一个K -bit密钥K，一个K -bit nonce N和一个任意大的消息M作为输入，生成一个大小为|M|的密文C。
该函数在算法3和图2.1d中描述。
它首先使用标志f = ENC调用IsapRk进行加密，以选择初始值IVKE和z = n - k，从而派生出一个(n - k)位的子密钥KE∗．一旦这个子键生成，
使用置换pE的常规基于海绵的流模式将在高速率rH下进行评估。IsapEnc是流模式，解密与M、C交换的角色相同。
认证加密E(K, N, A, M)
输入:密钥K∈{0,1}K, nonce N∈{0,1}k，关联数据A∈{0,1}∗，明文M∈{0,1}∗
输出: C∈{0,1}|M|， tag T∈{0,1}k
认证解密D(K, N, A, C, T)
输入:	key K∈{0,1}k，
nonce N∈{0,1}k，
关联数据A∈{0,1}∗，
C∈{0,1}∗，
tag T∈{0,1}k
输出: 明文M∈{0,1}|C|，或差错;
Verification
Y = H(N, A, C)
Ka∗ = g2(Y, K)
T0 = MACKa∗ (Y)
if T 6= T0 return ⊥
Decryption
Ke∗ = g1(N, K)
M = DECN,Ke∗ (C)
return M
Encryption/Decryption.加密和解密部分可以看作是新鲜重钥的一个实例[MSGR10;MPR + 11]。
这种新的重新加密方案结合了SPA安全加密方案ENC和(DPA和SPA)安全重新加密功能g1 :(N, K) 7→Ke∗．作为nonce N，
用于派生会话密钥Ke∗ 保证了新的会话密钥，有效地防止了加密方案ENC上的DPA。
然而，对于解密，存在这样的威胁:对手可能利用具有相同nonce N的多个解密，
从而使用相同的会话密钥Ke∗，并通过使用不同的数据在解密DEC内诱导DPA设置。
为了防止在我们的模式中出现这样的DPA场景，在解密之前要执行验证。
相同的Ke对两个不同的消息(关联数据和密文)进行解密∗ 表示g的碰撞1 对于固定的K(在我们的用例中，这个概率可以忽略不计)，或者两个使用同一个nonce n加密的密文。
因为我们需要唯一的nonce，后者意味着要么密文是相同的，要么一个密文被伪造了。
如果使用加密安全的MAC，成功伪造的概率是可以忽略的，因此对其中一个密文的标签验证将以压倒性的概率失败。
